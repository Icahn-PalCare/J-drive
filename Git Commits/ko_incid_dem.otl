= V4 Outline MultiLine NoSorting TabWidth=30

H="First Heading"
/* 
********************HEADING******************** 

Project Name: Incident Dementia 

Date Started: 3/23/20

Primary Investigator: Katherine Ornstein
Funding Source:

Created by: CY

Primary Analyst: CY
Secondary Analyst: EBL

Datasets Used: NHATS

Simple Outline: Using NHATS data to further homebound R01. Creating incident dementia sample  
*/

H="CY's Notes on Incident Dementia Start "
/*restrict sample to those who do not have prob_dem at wave 1 
not missing prob_dem 
ie. no pdem in wave 1, and missing pdem in wave2, and has pdem in w3: Flag & don't incl in pdem group 
might break down by cohort (2011 or 2015): using yearsample 
get estimates for each wave/cohort 
incid dementia: then, are they hb already, hb concurrently, hb next wave? 
do basic table 1: sample characteristics (can pull from hb_income)
*/

cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress" 
use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

*adjusted income 
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

*gets num of observations at wave where prob_dem first identified 
sort spid wave 
by spid: egen firstdem = min(cond(prob_dem ==1),wave,.)
label var firstdem "First Wave with Dementia"

*binary flag to flag wave only on waves that someone has 1st dem. 
by spid: gen flagwave= wave == firstdem
tab flagwave

*sets flagwave to 0 when missing dementia in previous obsv
by spid: replace flagwave = 0 if prob_dem[_n-1]==.
*setting to 0 when missing dementia status in prior wave 
tab flagwave
*id # of ppl (not obsv) w/ incident probable dementia after initial wave
**unweighted, get sample size at each wave

*Flag ppl with pdem @ wave 1 & wave 5 (not incid dementia)
gen pdem_w1_excl = 1 if firstdem == 1 & wave ==1 & yearsample ==2011

by spid: carryforward pdem_w1_excl, replace 
tab pdem_w1_excl,m 
label var pdem_w1_excl "Dementia at Wave 1 (to exclude)"
//drop if pdem_w1_excl == 1
//drop pdem_w1_excl

gen pdem_w5_excl = 1 if firstdem == 5 & wave ==5 & yearsample ==2015
by spid: carryforward pdem_w5_excl, replace
tab pdem_w5_excl
label var pdem_w5_excl "Dementia at Wave 5(2015 cohort to exclude)"

//drop if pdem_w5_excl == 1 
//drop pdem_w5_excl 

*indicator variable, priorstat is 1 if wave prior is has completed sp_ivw & not missing & wave prior doesn't have probable dementia
sort spid wave 
by spid:gen priorstat = 1 if wave-1 == wave[_n-1] & prob_dem[_n-1]==0 & sp_ivw[_n-1]==1
tab priorstat yearsample if flagwave ==1 & wave!= yearsample-2010, m
*check that num of SPs are the same as above. ok 
tab1 firstdem wave if flagwave ==1 & wave != yearsample-2010

*get list of spid with missing priorstat 
levelsof spid if flagwave ==1 & wave!= 1 & yearsample == 2011 & priorstat ==.

*breakdown by cohort year
tab priorstat if yearsample == 2011 & flagwave ==1, m
*1009 spids with incid dem from cohort 2011
tab priorstat if yearsample == 2015 & flagwave==1, m
*278 spids with incid dem from cohort 2015

*shows residential status of where ppl lived (community, res_care, nhres)
tab sp_status priorstat if priorstat==1 & firstdem == wave & wave!=wave-2010, col
*check
tab nhres priorstat if priorstat==1 & flagwave ==1 & wave!=wave-2010
tab rcfres priorstat if priorstat==1 & flagwave ==1 & wave!=wave-2010
tab commun priorstat if priorstat==1 & flagwave ==1 & wave!=wave-2010
tab wave yearsample, column

*see dementia pts in nursing homes (might not need this code below if using indivs above)
tab priorstat nhres if yearsample == 2011 & flagwave==1, m
gen nhres_dem = 1 if nhres ==1 & flagwave==1
tab firstdem nhres_dem

*see numbers to restrict nhres to those with priorstatus 
tab nhres_dem yearsample if priorstat == 1,m
 
*see num of obsv with sp_ivw & not lml with missing prob_dem  
tab prob_dem if !lml & sp_ivw == 1, m
*21 missing prob_dem 
tab priorstat if !lml & sp_ivw == 1 & flagwave ==1, m

*proxy is good to note for now and maybe flag later on in process 
tab prob_dem if !lml & proxy == 1 & flagwave==1, m
*12 missing prob_dem and proxy interviews 
tab prob_dem if !lml & proxy == 1 & flagwave==1, m
*325 proxy incid dem SPs  
 
*restrict to those who have Alive, SP ivw 
tab1 sp_ivw ivw_type 
*some with firstdem used proxy SP LML, so keep both sp_ivw & proxy?
*restrict to those who have Alive, SP ivw 

*subset sample of incid dementia ppts 
gen subset_dem = 1 if priorstat == 1 & flagwave ==1
tab subset

*create Waves as indicator variable to fill matrix 
gen newwave = wave
label define newwave 1 "Incid Dementia at Wave 1" 2 "Incid Dementia at Wave 2" 3"Incid Dementia at Wave 3" 4 "Incid Dementia at Wave 4" 5 "Incid Dementia at Wave 5" 6 "Incid Dementia at Wave 6" 7 "Incid Dementia at Wave 7" 8 "Incid Dementia at Wave 8" 
label values newwave newwave
tab newwave, gen(newwave)
forvalues i=1/8 {
local lab: label newwave `i'
label var newwave`i' "`lab'"
di "lab is `lab'"
}
label list newwave

*set up homebound categories 
label define homebound 1 "Never/Rarely leaves home" 2 "Leaves home but never by self" 3 "Leaves home but needs help/has difficul " 4 "Independent, not homebound"
label values homebound homebound
tab homebound, gen(homebound)
forvalues i = 1/4{
local lab: label homebound `i'
label var homebound`i' "`lab'"
di "label is `lab'"
}
label list homebound

label define agecat 1 "65-70" 2 "70-75" 3 "75-80" 4 "80-85" 5 "85-90" 6 "90-95"
label values agecat agecat 
tab agecat, gen(agecat)
forvalues i = 1/6{
local lab: label agecat `i'
label var agecat`i' "`lab'"
di "label is `lab'"
}


*Tables
**doesn't work. getting invalid syntax. 
local catvars maritalstat livearrang income_cat agecat
local cativars

mat tab2 = J(20,2,.)
foreach x of local catvars {
                local `x'
levelsof `x', local(levels)
                foreach l of local levels {                
                                gen `x'`l'=`x'==`l' if !missing(`x')
                                local lab : label `x' `l'
                                label var `x'`l' "`lab'"
                                local `x' ``x'' `x'`l'
}
              local cativars `cativars' ``x'' 
}

local r = 1
foreach x of local cativars{
sum `x' if `x'==1 & subset_dem == 1
di r(N)
*gettingn invalid syntax here 
mat tab2 [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tab2 [`r',2]= r(mean)*100
di r(mean)
local r = `r'+1
}
mat rownames tab2= `cativars'
mat list tab2

*not displaying variable labels... 
frmttable using 2samplesize.rtf, replace statmat(tab1) title("Test for CatVars") ctitles("" "N" "%" ) sdec(0,2) varlabels //substat(1) 
******************************************************
**labelling of table works for ivars but not for categorical 
local ivars newwave1 newwave2 newwave3 newwave4 newwave5 newwave6 newwave7 newwave8 agecat1 agecat2 agecat3 agecat4 agecat5 agecat6 female white black hisp other_race income_cat0 income_cat1 income_cat2 income_cat3 married marital_wid marital_div marital_sep marital_nev marital_sd livealone resspouse livearrang4 community nhres homebound1 homebound2 homebound3 homebound4 nhats_died_12  
local cvars age income_adj 

local rn: word count `cvars' `ivars' 2

mat tab1 = J(`rn',2,.)
local r=1
local c=1

sum subset 
mat tab1 [`r',1]= r(N)
local r = `r'+1

foreach x of local cvars {
sum `x' if subset==1 
mat tab1 [`r', 1]=r(N)
mat tab1 [`r',2]= r(mean)
local r = `r'+1
}

foreach x of local ivars{
sum `x' if `x'==1 & subset_dem == 1
mat tab1 [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tab1 [`r',2]= r(mean)*100
local r = `r'+1
}

mat rownames tab1 = "Total"  `cvars' `ivars'
mat list tab1

frmttable using 1samplesize.rtf, replace statmat(tab) title("Sample Size for Incident Dementia") ctitles("" "N" "%" ) sdec(0,2) varlabels //substat(1) 

*LATER: get next waves/linearity of prob_dem 
by spid: gen demnextwave= prob_dem[_n+1]

*tells if still alive in survey, & missing for those died/lfu 
*flag whenever person becomes hb, nhres, dies 
*find minimum wave of hb/nhres/dies & keep lowest of failure wave 

***hb status notes***
*identify first wave of homebound and remove if it comes before incid dementia wave
sort spid wave 


*apply this to hb var set up 
gen hbstatus=1 if sp_ivw==1 & !missing(homebound_cat)
replace hbstatus=2 if homebound_cat==1
replace hbstatus=3 if inlist(homebound_cat,2,3)
replace hbstatus=4 if nhres==1
label define hbstatus 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values hbstatus hbstatus
label var hbstatus "HB status this wave"

sort spid wave
gen comw=wave if hbstatus==1
gen hbw=wave if homebound_cat==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)

*see at which wave incid dem vs incid hb *can create indicator var 
tab newwave firsthb if subset_dem ==1, m nolab
tab newwave firstnh if subset_dem ==1, m nolab
tab newwave firstshb if subset_dem ==1, m nolab
tab newwave firstcom if subset_dem ==1, m nolab

*see nums of which wave is incid hb before incid dem wave **there are repeat obs here! *can create indicator var 
tab newwave firsthb if subset_dem ==1 & newwave>firsthb, m nolab
tab newwave firstnh if subset_dem ==1 & newwave>firstnh, m nolab
tab newwave firstshb if subset_dem ==1 & newwave>firstshb, m nolab
tab newwave firstcom if subset_dem ==1 & newwave>firstcom, m nolab


*hb at wave prior, @, & after incid dementia

***check why homebound prior is much lower than incid dementia wave
*182 in prior and 312 in during *****
*homebound at wave prior incid dementia 
sort spid wave 
gen hbflag_prior=1 if spid==spid[_n-1] & homebound_cat[_n-1]==1 & subset ==1 & wave-1==wave[_n-1] 
tab wave if hbflag_prior ==1
*****

*homebound at incid dementia wave 
sort spid wave 
gen hbflag_during=1 if homebound_cat==1 & subset ==1 
tab homebound_cat newwave if homebound_cat ==1 & subset ==1 
tab wave if hbflag_during ==1 
 
*id incid dementia 
sort spid wave
gen hbflag_after=1 if spid==spid[_n+1] & homebound_cat[_n+1]==1 & subset ==1 & wave+1==wave[_n+1]
tab wave if hbflag_after ==1 

*semi-hb at wave prior 
sort spid wave 
gen shbflag_prior = 1 if spid==spid[_n-1] & subset ==1 & wave-1==wave[_n-1] & homebound_cat[_n-1]==2
replace shbflag_prior = 1 if spid==spid[_n-1] & subset ==1 & wave-1==wave[_n-1] & homebound_cat[_n-1]==3
tab shbflag_prior

*semi-hb during incid dementia wave 
gen shbflag_during = 1 if subset ==1 & homebound_cat ==2
replace shbflag_during = 1 if subset ==1 & homebound_cat ==3
tab shbflag_during

*semihb after wave of incid dementia 
gen shbflag_after = 1 if spid==spid[_n-1] & subset ==1 & wave-1==wave[_n-1] & homebound_cat[_n-1]==2
replace shbflag_after = 1 if spid==spid[_n-1] & subset ==1 & wave-1==wave[_n-1] & homebound_cat[_n-1]==3
tab shbflag_after

tab wave if hbflag_d==1 & hbflag_p==1 & hbflag_a==1
*total of 59 hb in before/during/after

***spotcheck spids & waves for hbflag_prior 
tab hbflag_prior hbflag_during 
levelsof spid if hbflag_prior ==1 & hbflag_during==1
levelsof spid if hbflag_prior ==. & hbflag_during==1
levelsof spid if hbflag_prior ==1 & hbflag_during==.
tab hbflag_during hbflag_after
levelsof spid if hbflag_during==1 & hbflag_after==1
levelsof spid if hbflag_during==1 & hbflag_after==.
levelsof spid if hbflag_during==. & hbflag_after==1


*prior1during1
list spid wave firstdem prob_de homebound_cat hbflag_prior hbflag_dur if spid == 10002635 |spid ==10002647|spid ==10002688|spid ==10002700
*prior.during1
list spid wave firstdem prob_de homebound_cat hbflag_prior hbflag_dur if spid == 10002425 |spid ==10004362|spid ==10006889  |spid == 10010668
*prior1during.
list spid wave firstdem prob_de homebound_cat hbflag_prior hbflag_dur if spid ==  10005003 |spid == 10009710 |spid ==10011849  |spid == 20001679

*******table in progres below*******tabs & new vars are unnecessary******************
tab newwave homebound_cat if subset ==1
*need to add order. AFTER incid dementia... when does 1 have hb/shb/nh/death
*to remove repeat the obs & see obs of first time in nh OR hb OR shb
*specify if hb/shb/nh came first 
sort spid wave
gen orderhb = 1 if firsthb <firstnh 
replace orderhb = 1 if firsthb < firstshb
tab firstdem orderhb if subset ==1 & orderhb ==1
*total of 608
tab newwave firsthb if subset_dem ==1 & newwave<firsthb & orderhb==1, m nolab
*total of 213

gen ordernh = 1 if firstnh < firsthb |firstnh < firstshb
tab newwave firstnh if subset ==1 & ordernh ==1 & newwave <firstnh
*50 enter NH after incid dem 

gen ordershb =1 if firstshb<firsthb|firstshb<firstnh
tab firstshb newwave if subset ==1 & ordershb ==1 & newwave <firstshb
*178 of incid shb

*death at which wave 
gen deathatwave = newwave if nhats_died_12 == 1
tab firstdem deathatwave if subset == 1

tab firsthb if firsthb< firstnh|firsthb <firstshb & subset==1
tab firstnh if firstnh < firsthb|firstnh < firstshb & subset==1
tab firstshb if firstshb < firstnh|firstshb < firsthb & subset==1
*why are obs > 1287 even though subset is 1287

tab firsthb firstnh

local ivars newwave1 newwave2 newwave3 newwave4 newwave5 newwave6 newwave7 newwave8 deathatwave

forvalues i=1/8 {
sum deathatwave if deathatwave==`i' & subset==1
}

***********************Tables 

forvalues i=1/8 {
sum deathatwave if deathatwave==`i' & subset==1
}

local catvars deathatwave 
local cativars
foreach x of local catvars {
                local `x'
levelsof `x', local(levels)
                foreach l of local levels {                
                                gen `x'`l'=`x'==`l' if !missing(`x')
                                local lab : label `x' `l'
                                label var `x'`l' "`lab'"
                                local `x' ``x'' `x'`l'
}
              local cativars `cativars' ``x'' 
}
mat rownames tab= `cativars'
mat list tab


local rn : word count `cativars'
local r=10
local c=10

foreach y of local catvars {
               foreach x of local `y' {
                forvalues i=0/1 {
                                sum `x'  
                                mat tab[`r',`c']=r(mean)*r(N)
                                mat tab[`r',`c']=r(mean)*100
                                local c=`c'+2
}
}
                local r=`r'+1
                local c=1
}
mat rownames tab= `cativars'
mat list tab 


H="Sample Derivations&Tables"
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress" 
use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

*gets num of observations at wave where prob_dem first identified 
sort spid wave 
by spid: egen firstdem = min(cond(prob_dem ==1),wave,.)
label var firstdem "First Wave with Dementia"

*binary flag to flag wave only on waves that someone has 1st dem. 
by spid: gen flagwave= wave == firstdem

*sets flagwave to 0 when missing dementia status in previous obsv
by spid: replace flagwave = 0 if prob_dem[_n-1]==.
tab flagwave

*Flag ppl with pdem @ wave 1 & wave 5 (need to excl b/c not incid dementia)
gen pdem_w1_excl = 1 if firstdem == 1 & wave ==1 & yearsample ==2011
by spid: carryforward pdem_w1_excl, replace 
label var pdem_w1_excl "Dementia at Wave 1 (2011 cohort to exclude)"

gen pdem_w5_excl = 1 if firstdem == 5 & wave ==5 & yearsample ==2015
by spid: carryforward pdem_w5_excl, replace
label var pdem_w5_excl "Dementia at Wave 5(2015 cohort to exclude)"

*indicator variable, priorstat is 1 if wave prior is has completed sp_ivw & not missing & wave prior doesn't have probable dementia
sort spid wave 
by spid:gen priorstat = 1 if wave-1 == wave[_n-1] & prob_dem[_n-1]==0 & sp_ivw[_n-1]==1

*specific sample of incid dementia ppts 
gen subset_dem = 1 if priorstat == 1 & flagwave ==1

*get LFU counts
by spid: gen lfu = 1 if wave+1!=wave[_n+1] & subset ==1

*get nursing home in wave prior 
by spid: gen nhprior = nhres[_n-1]==1 if subset ==1

*exclude NH prior & LFU after from subset 
gen exclset = 1 if lfu!=1 & nhprior !=1 & subset ==1

*hb wave prior to incid dem
sort spid wave 
gen hbflag_prior= spid==spid[_n-1] & homebound_cat[_n-1]==1 & wave-1==wave[_n-1] if subset ==1 
label var hbflag_prior "HB Prior Wave"

*homebound at incid dementia wave 
sort spid wave 
gen hbflag_during=homebound_cat==1 if subset ==1 
label var hbflag_during "HB Same Wave"
 
*hb after incid dementia wave
sort spid wave
gen hbflag_after=spid==spid[_n+1] & homebound_cat[_n+1]==1 & wave+1==wave[_n+1] if subset ==1 
label var hbflag_after "HB After Wave"

*semi-hb at wave prior 
sort spid wave 
gen shbflag_prior = spid==spid[_n-1]  & wave-1==wave[_n-1] & homebound_cat[_n-1]==2 if subset ==1
replace shbflag_prior =1 if spid==spid[_n-1] & wave-1==wave[_n-1] & homebound_cat[_n-1]==3 & subset ==1
label var shbflag_prior "SHB Prior Wave"

*semi-hb during incid dementia wave 
gen shbflag_during = homebound_cat ==2 if subset ==1 
replace shbflag_during=1 if homebound_cat ==3 & subset ==1 
label var shbflag_during "SHB Same Wave"

*semihb after wave of incid dementia 
gen shbflag_after=spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==2 if subset ==1
replace shbflag_after = 1 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==3 & subset ==1 
label var shbflag_after "SHB After Wave"

label var age "Mean Age"
label define agecat 1 "Age 65-70" 2 "Age 70-75" 3 "Age 75-80" 4 "Age 80-85" 5 "Age 85-90" 6 "Age 90-95"
label values agecat agecat 

label define income_quart 1 "Income Bottom" 2 "Income Second" 3 "Income Third" 4 "Income Top", modify

label define livearrang 1 "Alone" 2 "Lives w. Spouse/Partner" 3 "Lives w. Spouse/Partner+Others" 4 "Lives w. Others", modify 

local catvars livearrang income_quart agecat wave
local cativars

foreach x of local catvars {
                local `x'
levelsof `x', local(levels)
                foreach l of local levels {                
                                gen `x'`l'=`x'==`l' if !missing(`x')
                                local lab : label `x' `l'
                                label var `x'`l' "`lab'"
                                local `x' ``x'' `x'`l'
}
              local cativars `cativars' ``x'' 
}

*Table: Incid Dementia at Wave (Including those LFU after wave & in NH in wave Prior)
local waves wave1 wave2 wave3 wave4 wave5 wave6 wave7 wave8 
local rn: word count `waves' 2
mat tabwave = J(`rn',4,.)

local r=1
foreach x of local waves {
tab `x' if `x'==1 & subset_dem == 1 & yearsample ==2011
mat tabwave [`r',1]=r(N)
tab `x' if `x'==1 & subset_dem == 1 & yearsample ==2015
mat tabwave [`r',2]=r(N)
sum `x' if `x'==1 & subset_dem == 1
mat tabwave [`r',3]= r(N)
sum `x' if subset_dem == 1
mat tabwave [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset if subset_dem == 1 & yearsample ==2011
mat tabwave [`r',1]= r(N)
sum subset if subset_dem == 1 & yearsample ==2015
mat tabwave [`r',2]= r(N)
sum subset 
mat tabwave [`r',3]= r(N)
mat tabwave [`r',4]=r(mean)*100

mat rownames tabwave = `waves' "Total"
mat list tabwave

frmttable using incid_dementia_tables.rtf, replace statmat(tabwave) title("Wave at Incident Dementia by Cohort (incl. NH Prior & LFU After)") ctitles("" "2011 Only" "2015 Only" "Total" "% of Total" ) sdec(0,0,0,2) varlabels note ("Incident Dementia for both 2011 & 2015 cohort (excludes those who entered with dementia)")

*Table: Incid Dementia at Wave (Show Censoring w8 & LFU after wave & in NH in wave Prior)
local waves wave1 wave2 wave3 wave4 wave5 wave6 wave7 wave8 
local rn: word count `waves' 2
mat tabcensor = J(`rn',4,.)

local r=1
foreach x of local waves {
tab `x' if `x'==1 & subset == 1 & nhprior ==1 
mat tabcensor [`r',1]=r(N)
tab `x' if `x'==1 & subset_dem == 1 & lfu ==1 
mat tabcensor [`r',2]=r(N)
sum `x' if `x'==1 & subset_dem == 1 & lfu!=1 & nhprior !=1
mat tabcensor [`r',3]= r(N)
sum `x' if subset_dem == 1 & lfu!=1 & nhprior !=1
mat tabcensor [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset if subset_dem == 1 & nhprior==1
mat tabcensor [`r',1]= r(N)
sum subset if subset_dem == 1 & lfu ==1 
mat tabcensor [`r',2]= r(N)
sum subset if lfu!=1 & nhprior !=1 
mat tabcensor [`r',3]= r(N)
mat tabcensor [`r',4]=r(mean)*100

mat rownames tabcensor = `waves' "Total"
mat list tabcensor

frmttable using incid_dementia_tables.rtf, addtable statmat(tabcensor) title("Wave at Incident Dementia by NH Prior & LFU After") ctitles(""  "NH in Prior Wave" "LFU/Censor in Next Wave" "Remaining Incid Dem Pop" "% of Remaining Incid Dem Pop" ) sdec(0,0,0,2) varlabels note ("**LFU & NH Prior is NOT mutually exclusive. (1 ppt is counted twice due to being in NH in prior Wave & LFU in next wave.)")

*Table: Homebound Status Before/During/After Incident Dementia Wave 
local hbvars hbflag_prior hbflag_during hbflag_after shbflag_prior shbflag_during shbflag_after 
local rn: word count `hbvars' 
mat tabhb = J(`rn',4,.)
local r=1

foreach x of local hbvars{
sum `x' if `x'==1 & subset_dem == 1
mat tabhb [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tabhb [`r',2]= r(mean)*100

sum `x' if `x'==1 & exclset ==1
mat tabhb [`r',3]= r(N)
sum `x' if exclset ==1
mat tabhb [`r',4]= r(mean)*100
local r = `r'+1
}

mat rownames tabhb = `hbvars' 

frmttable using incid_dementia_tables.rtf, addtable statmat(tabhb) title("Homebound and Incident Dementia") ctitles("" "N(incl LFU&NH)" "%(incl LFU&NH)" "N(excl LFU&NH)" "%(excl LFU&NH)" ) sdec(0,2,0,2) varlabels


*Table: Demographics inclusive of LFU & NH 
local ivars income_quart1 income_quart2 income_quart3 income_quart4  agecat1 agecat2 agecat3 agecat4 agecat5 agecat6 female white black hisp other_race marital_nev married marital_wid marital_sd livealone resspouse livearrang4 community nhres nhats_died_12  
local cvars age 

local rn: word count `cvars' `ivars' 2

mat tab = J(`rn',4,.)
local r=1

foreach x of local cvars {
sum `x' if subset==1 
mat tab [`r',1]=r(N)
mat tab [`r',2]= r(mean)
sum `x' if exclset==1 
mat tab [`r',3]=r(N)
mat tab [`r',4]= r(mean)
local r = `r'+1
}

foreach x of local ivars{
sum `x' if `x'==1 & subset_dem == 1
mat tab [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tab [`r',2]= r(mean)*100
sum `x' if `x'==1 & exclset == 1
mat tab [`r',3]= r(N)
sum `x' if exclset == 1
mat tab [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset 
mat tab [`r',1]= r(N)
sum exclset 
mat tab [`r',3]= r(N)

mat rownames tab = `cvars' `ivars' "Total" 

frmttable using incid_dementia_tables.rtf, addtable statmat(tab) title("Demographics for Incident Dementia") ctitles("" "N(incl LFU&NH)" "%(incl LFU&NH)" "N(excl LFU&NH)" "%(excl LFU&NH)") sdec(0,2,0,2) varlabels note ("All variables, except Mean Age, are categorical.")

*********************UNWEIGHTED TABLE 1, MIGHT NOT RUN B/C OF VAR CHANGES**************

/*
**Table 1: 2011 Cohort Unweighted 
*incicat (t) 0: not hb, 1 hb in priorwave/concurrently
preserve
keep if incident & yearsample ==2011
local cvars1 age tot_hrswk_help_i
local ivars1 female married educ_hs_ind
local catvars1 race3
local cvars2 adl_index 
local ivars2 ind_paid_help  rcfres livealone metro_ind
local catvars2 comorbid 
local catvars3 income_quart
local catvars4 nhelpers3
local ivars5 hrs_help_2cat
local catvars5 hrs_help_3cat

gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 1 1 
local r=1
local c=1

mat tab=J(`rn',4,.)
mat stars=J(`rn',4,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}
tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: mean ltpov 
mat tab[`r',`c']= e(b_mi)*100
mi estimate: mean ltpov if incicat ==0 
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate: mean ltpov if incicat ==1
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate: reg ltpov incicat if inlist(incicat,1,0)
mat tab[`r',`c'+3]=e(p_mi)
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 
***********************
local r = 2
forvalues i=1/5 {
	foreach x of local cvars`i' {
	sum `x'   
		mat tab[`r',`c']=r(mean)
	
		local r=`r'+1		
}
	foreach x of local ivars`i' {
		sum `x' 
		 mat tab[`r',`c']=r(mean)*100
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x'  
		local r=`r'+1
		foreach z of local `x' {
			sum `z' 
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
			}
}

}
	svy: mean n
	mat tab[`r',`c']=e(N_psu)
	local r = `r'+1 
	mat tab[`r',`c']=e(N_pop)
		

local r = 2
local c = 2

foreach t in 0 1 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
	sum `x' if incicat==`t'  //gives same #s
		mat tab[`r',`c']=r(mean)
		if `t'==1 {
			reg `x' incicat if inlist(incicat,`t',0)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t' 
		 mat tab[`r',`c']=r(mean)*100

		if `t'==1 {
		tab `x' incicat if inlist(incicat,`t',0), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t' 
		if `t'==1 {
		tab `x' incicat if inlist(incicat,`t',0), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t' 
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
			}
}
}

	sum n if incicat==`t' [aw=anfinwgt]
	mat tab[`r',`c']==r(N)
	local r = `r'+1 
	mat tab[`r',`c']==r(sum_w)
	local r=2
	local c=`c'+1
	
}	

mat rownames tab= "Poverty Threshold" `rows'  N "Estimated N"

mat list tab

*frmttable using "inci_dem_tab1_2011only_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort-No Survey Weights") ctitles("" "Incident Dementia Full Sample" "Incidem & non-HB" "Incidem & HB(Prior-Concur)" "P-value") varlabels sdec(2,2,2,3) annotate(stars) asymbol(*,**,NR) addtable note("P-values for homebound, relative to non-homebound group") 

restore

*/

H="Severe Dementia & ADLs Table 1"
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

*don't use ADL Outside (adl_out_help)
*adls: bath dres eat toil ins bed 
*adl counts: adl_same_count adl_incr_count adl_decr_count

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"

*below confirm that adl_index numbers are correct 
*egen testcounts = rowtotal(adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help ) if !missing(adl_eat_help) &!missing(adl_bath_help) &!missing(adl_toil_help) & !missing(adl_dres_help) & !missing(adl_ins_help )& !missing(adl_bed_help)  

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status 
keep if sp_ivw==1 & !missing(prob_dem)

sort spid wave
*get wave of first time probable dementia is indicated
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

*get wave of first nh resident 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
*possible dementia at prior wave 
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for those who are hb
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
*prob dementia score in prior wave 

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"
tab incicat if incid ==1

*create var of adl impairment in prior wave 
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
tab1 race race3
label define race3 1 "White & Other(Non-Hisp)" 2 "Black(Non-Hisp)" 3 "Hispanic"
label values race3 race3
label var race3 "Race (White&Other/Black/Hispanic)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

gen ind_help40hrs=tot_hrswk_help_i>40
label var ind_help40hrs "Indicator: Help >40+ hrs wk"

*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

gen sev_dem=0
replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

tab1 ind_*_adl_counts if incid ==1

/**check for adl_change vars 
levelsof spid if adl_change ==0 & incident==1
levelsof spid if adl_change ==1 & incident==1
levelsof spid if adl_change ==2 & incident==1
levelsof spid if adl_change ==. & incid==1
 
tab adl_change if incid==1 
levelsof spid if incid ==1 & adl_change==. 

tab adl_same_count if incid ==1
tab adl_incr_count if incid ==1
tab adl_decr_count if incid ==1
*/

/*look at cross tabs of severe dementia hb cats & vars 
use adl_var_help variables 
look at adl index/counts and break into 3 ish categories 
report %s not N 

if looking at decline, use raw adl counts from previous stage. 
categories would be adl count increased, decreased, or stayed the same 
*/

preserve
keep if incident
foreach x in hb sev_dem-sev_dem0_hb1  {
tab1 `x'
}
sum hb sev_*
restore 

*look at freqs btwn sev_dem_hb status & adl_help 
preserve 
keep if incident 
local sevhb sev_dem hb sev_dem_hb sev_dem0_hb0 sev_dem1_hb0 sev_dem0_hb1
local adl_list adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help  adl_*_count ind_*_adl_counts 
foreach y of local sevhb{
foreach x of local adl_list{
*tab `y' `x', m row
*qui sum `x' if `y'==0
sum `x' if `y'==1
}
}
restore 

*table of frequencies of severe dementia, hb, adls
preserve 
keep if incident 
local sevhb sev_dem0_hb0 hb sev_dem sev_dem_hb sev_dem1_hb0 sev_dem0_hb1
local all_adl_list adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help  adl_same_count adl_incr_count adl_decr_count ind_no_adl_counts ind_one_adl_counts ind_four_adl_counts 

local rn: word count `all_adl_list' 1 1 
local r = 1
local c = 1
mat tab =J(`rn',6,.)
foreach y of local sevhb{
foreach x of local all_adl_list{
sum `x' if `y'==1
mat tab [`r',`c'] = r(mean)*100
local r=`r'+1
sum `y' if `y'==1
mat tab [`r',`c'] = r(N)
}
local r = `r'+1
sum `y'
mat tab [`r',`c']= r(mean)*100
local c=`c'+1
local r = 1
}
mat list tab 

mat rownames tab = `all_adl_list' "N" "% of N in Incid Dementia"
frmttable using adl_counts20200515.rtf, replace statmat(tab) varlabels ctitles("" "No SevDem & No HB" "HB only" "SevDem Only" "SevDem & HB"  "SevDem & NotHB" "NotSevDem & HB") title (Percents of ADLs among Severe Dementia & HB Status) note(sevdem: Severe Dementia  using Jenny's definition, HB status at Incident Dementia)

*among those of column X, % of them are part of row A
*among those with no severe dementia & not hb, 8.78% has help while eating 

restore 


gen n = 1
preserve 
keep if incident
local ind_adl_list adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help 
local cat_adl_list adl_change adl_3cat_counts
local adl_statchange adl_same_count adl_incr_count adl_decr_count 
local adl_counts ind_no_adl_counts ind_one_adl_counts ind_four_adl_counts 

local rn: word count `ind_adl_list' `adl_statchange' `adl_counts'  1 1 1 
di "`rn'"
local r = 1
local c = 1
mat tab1 =J(`rn',3,.)
mat stars=J(`rn',3,0)
foreach t in 1 0 {
foreach x of local ind_adl_list {
sum `x' if incicat==`t'
mat tab1[`r',`c']=r(mean)*100

if `t'==0 {
tab `x' incicat if inlist(incicat,`t',1), chi2
mat tab1[`r',`c'+1]=r(p)
mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)

}
local r=`r'+1
}

foreach x of varlist adl_change {
if `t'==0 {
tab adl_change incicat if inlist(incicat,`t',1), chi2 
mat tab1[`r',`c'+1]=r(p)
mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)

}
local r = `r'+1
}

foreach y of local adl_statchange{
sum `y' if incicat==`t'
mat tab1[`r',`c']=r(mean)*100
local r = `r'+1
}

foreach x of varlist adl_3cat_counts {
if `t'==0 {
tab adl_change incicat if inlist(incicat,`t',1), chi2 
mat tab1[`r',`c'+1]=r(p)
mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)

}
local r = `r'+1
}

foreach y of local adl_counts{
sum `y' if incicat==`t'
mat tab1[`r',`c']=r(mean)*100
local r = `r'+1
}
sum n if incicat==`t'
mat tab1[`r',`c']==r(N)
local r = 1

local c = `c'+1
}

mat list tab1 

mat rownames tab1 = `ind_adl_list' adl_change `adl_statchange' adl_3cat_counts `adl_counts' "N" 
frmttable using adl_counts20200515.rtf, addtable statmat(tab1) varlabels ctitles("" "HBn1 or ConcurHB" "Indep" "P-Value") title (Characteristics of ADLs and 'HB@n1 or Concurrently HB') note ("p-values relative to Independent group") annotate(stars) asymbol(*,**,NR)

restore

**below is some code for cativars. need to troubleshoot & figure out*** 
/*
*code to figure out cativars issues 
gen n = 1
preserve 
keep if incident
local ind_adl_list adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help 
local cat_adl_list adl_change adl_3cat_counts
local icat_adl_list adl_same_count adl_incr_count adl_decr_count ind_no_adl_counts ind_one_adl_counts ind_four_adl_counts 


***
/*
foreach x of local cat_adl_list {
local cativars
gen l`x'= . 
local lab: var label `x'
label var l`x' "`lab'"
di "`x'"
di "l`x'"
local `x'
levelsof `x', local (levels)
foreach l of local levels {
gen `x'`l'=`x'==`l' if !missing(`x')
local lab: label `x' `l'
label var `x'`l' "`lab'"
local `x' ``x'' `x'`l'
}
di "``x''"
local cativars `cat_adl_list' ``x''
}
*/
****
local rn: word count `ind_adl_list' `cat_adl_list' `icat_adl_list'  1 
di "`rn'"
local r = 1
local c = 1
mat tab1 =J(30,3,.)
mat stars=J(30,3,0)
foreach t in 1 0 {
foreach x of local ind_adl_list {
sum `x' if incicat==`t'
mat tab1[`r',`c']=r(mean)*100

if `t'==0 {
tab `x' incicat if inlist(incicat,`t',1), chi2
mat tab1[`r',`c'+1]=r(p)
mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)

}
local r=`r'+1
}


sum n if incicat==`t'
mat tab1[`r',`c']==r(N)
local r = 1
local c = `c'+1

}

mat list tab1 

mat rownames tab1 = `ind_adl_list' `cat_adl_list' `cativars' "N" 
frmttable using adl_counts20200515.rtf, addtable statmat(tab1) varlabels ctitles("" "HBn1 or ConcurHB" "Indep" "P-Value") title (Characteristics of ADL Variables and HB ) note ("p-values relative to Independent group") annotate(stars) asymbol(*,**,NR)


/*

foreach y of local cat_adl_list{
sum `y' if incicat ==`t'
if `t'==0 {
tab `y' incicat if inlist(incicat,`t',1), chi2 
mat tab1[`r',`c'+1]=r(p)
mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
local r=`r'+1


foreach z of local icat_adl_list {
sum `z' if incicat==`t'
mat tab1[`r',`c']=r(mean)*100
local r=`r'+1

}

}
*/
*/



H="Archive Logit Models incl. ADL for HB & nonHB "
*logits 
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

*don't use ADL Outside (adl_out_help)
*adls: bath dres eat toil ins bed 
*adl counts: adl_same_count adl_incr_count adl_decr_count

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"

*below confirm that adl_index numbers are correct 
*egen testcounts = rowtotal(adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help ) if !missing(adl_eat_help) &!missing(adl_bath_help) &!missing(adl_toil_help) & !missing(adl_dres_help) & !missing(adl_ins_help )& !missing(adl_bed_help)  

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status 
keep if sp_ivw==1 & !missing(prob_dem)

sort spid wave
*get wave of first time probable dementia is indicated
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

*get wave of first nh resident 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
*possible dementia at prior wave 
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for those who are hb
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
*prob dementia score in prior wave 

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"
tab incicat if incid ==1

*create var of adl impairment in prior wave 
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
tab1 race race3
label define race3 1 "White & Other(Non-Hisp)" 2 "Black(Non-Hisp)" 3 "Hispanic"
label values race3 race3
label var race3 "Race (White&Other/Black/Hispanic)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

gen ind_help40hrs=tot_hrswk_help_i>40
label var ind_help40hrs "Indicator: Help >40+ hrs wk"

*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

gen sev_dem=0
replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

local cfullvars age income_adj tot_hrswk_help_i 
local ifullvars agecat income_quart bottomincome topincome female married educ_hs_ind race race3 srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper num_helpers_cat nhelpers3

foreach x of local ifullvars{
tab `x' if incident ==1 
} 

*check combinations of other race & white/black/hispanic categories 
/*
gen blackother = 1 if race==1 
replace blackother = 2 if race==3 
replace blackother = 2 if race ==2
replace blackother = 3 if race==4 
tab1 race blackother

gen hispother = 1 if race==1 
replace hispother = 3 if race==3 
replace hispother = 2 if race ==2
replace hispother = 3 if race==4 
tab1 race hispother

local catrace race race3 blackother hispother
foreach x of local catrace {
logit incicat `x' if incident==1
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x'  Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}
*confirms that white+others is best combo for recategorizing white 

*choose either livearrang or married, but not both b/c most married live w/ spouse/partner, + others, while not married lives alone or with others 

*model selection for demographic vars only
preserve
keep if incident 
local agevar age agecat 
local incomevar income_adj i.income_quart bottomincome topincome
local racevar i.race i.race3 
local demovars female educ_hs_ind srh_fp rcfres  
local marital_living married i.livearrang
local hbvars shb_n1 adl_imp_n1 adl_impair

foreach y of local incomevar{
foreach x of local agevar{
foreach z of local racevar {
foreach w of local marital_living{
qui logit incicat `x' `y' `z' `demovars' `hbvars' `marital_living', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x' & `y' & `z' & `w' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}
}
}
}

*best model for demographics: age & bottomincome & i.race3 & i.livearrang Pseudo r:.23_ AIC:1074.76_ BIC:1155.79_LROC:.82

*add signif homedisorder vars & assistance vars & check models for num of helpers, indicator of no pd help & hrs of help 
preserve 
keep if incident 
local demovars age bottomincome i.race3 female educ_hs_ind srh_fp rcfres i.livearrang shb_n1 adl_imp_n1 adl_impair 
local signifvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers i.num_help nhelpers3 n_family_helpers ind_family_help n_paid_helpers i.ind_paid_helper tot_hrswk_help_i ind_help40hrs //ind_gt20hrs_wk_inf tot_otherinformalhrs ind_gt20hrs_wk_paid tot_paidhrs    

foreach x of local helpvars{
qui logit incicat `x' `demovars' `signifvars', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' `num' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

}
restore

*Helper Vars for Model based on AIC & BIC: n_helpers (as continuous), ind_paid_helper, ind_help40hrs 


*rename ind_gt40 ind_help40hrs
*Tables w/ all vars selected  & removed 4 vars 
preserve
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
local finanvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars i.adl_change i.nhelpers3 ind_help40hrs i.adl_3cat_counts adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help adl_imp_n1 


*local title "`HB & Num Helper'" "`HB & Pd Help'" "`HB & 40+hs Help'"
outreg, clear 
logit incicat `modelvars' i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or 


foreach x of local helpvars{
qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local num = r(N)
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' popln:`num' r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"


*qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}


*outreg using modselect_selectvars_20200510v4.rtf, replay replace title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangment: Live Alone")

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

restore

/*
Notes for margin effects: to get change in vars. useful for interaction terms. ie. look at full or interaction effect. or look at something over a value. ie. look at age at 65, 75, 85

logit incicat i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or

*get predictive margins of adl_3cat_count
margins adl_3cat_counts

*get average marginal effects of adl_3cat_count
margins, dydx(adl_3cat_counts)

*to get average from marginal effects. take category of interest - reference cat 
*in example: 4-6adl: 0.53, no adl: 0.13 >> avge ME: 0.53-0.13 = 0.40

*get predictive margins of adl_change
margins, dydx(adl_change)

*gets margins by categories. so in adl_change, what is the adl counts... 
margins, dydx(adl_change) over (adl_3cat_count)

*gets margins of all the vars from logit 
margins, dydx (*)


*/

H="Selection Process for Logit Models "
*clean this one up to just get current model 
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

import excel "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) //nogen 

sort ivw_year hhm

levelsof spid if hhm>9 & hhm<.

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*gen poverty indicator for ppl income is less than poverty threshold 
gen poverty_ind= poverty_thresh >= aveincome & poverty_thresh!=.
replace poverty_ind =. if poverty_thres==.
tab poverty_ind
label var poverty_ind "Poverty Indicator"

*don't use ADL Outside (adl_out_help)
*adls: bath dres eat toil ins bed 
*adl counts: adl_same_count adl_incr_count adl_decr_count

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"

*below confirm that adl_index numbers are correct 
*egen testcounts = rowtotal(adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help ) if !missing(adl_eat_help) &!missing(adl_bath_help) &!missing(adl_toil_help) & !missing(adl_dres_help) & !missing(adl_ins_help )& !missing(adl_bed_help)  

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status 
keep if sp_ivw==1 & !missing(prob_dem)

sort spid wave
*get wave of first time probable dementia is indicated
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

*get wave of first nh resident 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
*possible dementia at prior wave 
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for those who are hb
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
*prob dementia score in prior wave 

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"
tab incicat if incid ==1

*create var of adl impairment in prior wave 
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
tab1 race race3
label define race3 1 "White & Other(Non-Hisp)" 2 "Black(Non-Hisp)" 3 "Hispanic"
label values race3 race3
label var race3 "Race (White&Other/Black/Hispanic)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

gen ind_help40hrs=tot_hrswk_help_i>40
label var ind_help40hrs "Indicator: Help >40+ hrs wk"

*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

gen sev_dem=0
replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

local cfullvars age income_adj tot_hrswk_help_i 
local ifullvars agecat income_quart bottomincome topincome female married educ_hs_ind race race3 srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper num_helpers_cat nhelpers3

foreach x of local ifullvars{
tab `x' if incident ==1 
} 

*check combinations of other race & white/black/hispanic categories 
gen blackother = 1 if race==1 
replace blackother = 2 if race==3 
replace blackother = 2 if race ==2
replace blackother = 3 if race==4 
tab1 race blackother

gen hispother = 1 if race==1 
replace hispother = 3 if race==3 
replace hispother = 2 if race ==2
replace hispother = 3 if race==4 
tab1 race hispother

local catrace race race3 blackother hispother
foreach x of local catrace {
logit incicat `x' if incident==1
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x'  Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}
*confirms that white+others is best combo for recategorizing white 

*choose either livearrang or married, but not both b/c most married live w/ spouse/partner, + others, while not married lives alone or with others 

*model selection for demographic vars only
preserve
keep if incident 
local agevar age agecat 
local incomevar income_adj i.income_quart bottomincome topincome
local racevar i.race i.race3 
local demovars female educ_hs_ind srh_fp rcfres  
local marital_living married i.livearrang
local hbvars shb_n1 adl_imp_n1 adl_impair

foreach y of local incomevar{
foreach x of local agevar{
foreach z of local racevar {
foreach w of local marital_living{
qui logit incicat `x' `y' `z' `demovars' `hbvars' `marital_living', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x' & `y' & `z' & `w' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}
}
}
}
restore 
*best model for demographics: age & bottomincome & i.race3 & i.livearrang Pseudo r:.23_ AIC:1074.76_ BIC:1155.79_LROC:.82

*add signif homedisorder vars & assistance vars & check models for num of helpers, indicator of no pd help & hrs of help 
preserve 
keep if incident 
local demovars age bottomincome i.race3 female educ_hs_ind srh_fp rcfres i.livearrang shb_n1 adl_imp_n1 adl_impair 
local signifvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers i.num_help nhelpers3 n_family_helpers ind_family_help n_paid_helpers i.ind_paid_helper tot_hrswk_help_i ind_help40hrs //ind_gt20hrs_wk_inf tot_otherinformalhrs ind_gt20hrs_wk_paid tot_paidhrs    

foreach x of local helpvars{
qui logit incicat `x' `demovars' `signifvars', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' `num' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

}
restore
*Helper Vars for Model based on AIC & BIC: n_helpers (as continuous), ind_paid_helper, ind_help40hrs 


*Tables w/ all vars selected  & removed 4 vars 
preserve
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 adl_imp_n1 adl_impair 
local finanvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers ind_paid_helper ind_help40hrs 
*local title "`HB & Num Helper'" "`HB & Pd Help'" "`HB & 40+hs Help'"
outreg, clear 
foreach x of local helpvars{
/*
qui logit incicat `modelvars' `finanvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' All Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/

qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}

*outreg using modselect_selectvars_20200510v4.rtf, replay replace title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangment: Live Alone")

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

restore


***caregiving variables*** 
/*full list of vars:
age agecat income_adj i.income_quart bottomincome topincome female married educ_hs_ind race srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper tot_hrswk_help_i  
*/

*model selection for ADL variables & function*
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
local helpvars i.adl_change i.nhelpers3 ind_help40hrs i.adl_3cat_counts adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help adl_imp_n1 adl_index

foreach x of local helpvars{
qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local num = r(N)
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' popln:`num' r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

*qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

*****check margin effects for models*****
*Notes for margin effects: to get change in vars. useful for interaction terms. ie. look at full or interaction effect. or look at something over a value. ie. look at age at 65, 75, 85

logit incicat i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or

*get predictive margins of adl_3cat_count
margins adl_3cat_counts

*get average marginal effects of adl_3cat_count
margins, dydx(adl_3cat_counts)

*to get average from marginal effects. take category of interest - reference cat 
*in example: 4-6adl: 0.53, no adl: 0.13 >> avge ME: 0.53-0.13 = 0.40

*get predictive margins of adl_change
margins, dydx(adl_change)

*gets margins by categories. so in adl_change, what is the adl counts... 
margins, dydx(adl_change) over (adl_3cat_count)

*gets margins of all the vars from logit 
margins, dydx (*)

restore

**Selected Model for ADL****
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
logit incicat `modelvars' i.adl_3cat_counts if incident, or
estat ic 
lroc 
*outreg using models_adl20200521v4.rtf, merge stats(e_b e_ci p) ctitles("" "ADL Categorical") varlabels title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangement: Live Alone. Referent ADL Category: No ADLs")

label var adl_index "ADL Counts (Continuous)"
logit incicat `modelvars' adl_index if incident, or 
estat ic 
lroc 
*outreg using models_adl20200521v4.rtf, merge stats(e_b e_ci p) ctitles("" "ADL Continuous") varlabels 

restore 

*selection model for financial help 
preserve 
keep if incident 
local modelvars age i.race3 married marital_wid marital_sd rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 paid_help_ind livealone
local finhelpvars finhlpfam section8 meals_wheels govtasst
foreach x of local finhelpvars{
qui logit incicat `modelvars' `x' adl_index, or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}

*live arrang/married vars 
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 paid_help_ind 
qui logit incicat `modelvars' adl_index married marital_wid marital_sd livealone if incident, or
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*Less Vars Pseudo r:.23_ AIC:1044.81_ BIC:1125.16_LROC:.82

*kept categorical live alone, added paid help, removed marital status 
qui logit incicat `modelvars' adl_index i.livearrang if incident, or
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*Pseudo r:.23_ AIC:1048.7_ BIC:1124.04_LROC:.8100000000000001

restore 

H="Evan's tables"


H="table 1 and caregiving resources, 3 categories"
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

label var income_adj "Income, 2018$"
keep if sp_ivw==1 & !missing(prob_dem)
sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
by spid: egen firstnh=min(cond(nhres==1),wave,.)
drop if firstnh<=firstdem | missing(firstdem)
rename race_cat race
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2

label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"
gen incicat=hbcat_n1==1
replace incicat=2 if !incicat & hbcat==1
replace incicat=3 if !incicat & inlist(hbcat,2,3)
tab incicat
label define incicat 1 "Homebound at N1" 2 "Concurrently homebound" 3 "Not homebound"
label values incicat incicat
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

local home 
foreach x of varlist home_di* {
	local home `home' `x'
}

preserve
keep if incident
local cvars1 age 
local ivars1 female married educ_hs_ind
local catvars1 race
local cvars2 income_adj
local ivars2 
local catvars2 income_quart
local ivars3 shb_n1 possdem_n1 adl_imp_n1 adl_impair srh_fp rcfres
local catvars3 livearrang
local ivars4
gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 1 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'<3 {
			reg `x' incicat if inlist(incicat,`t',3)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+2
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB at N1" "P-value" "Concurrent HB" "P-value" "Non-HB") varlabels ///
sdec(2,3,2,3,2) annotate(stars) asymbol(*,**,NR) replace note("P-values relative to non-homebound group")

restore

keep if incident
local cvars1 n_helpers
local ivars1 ind_no_helpers ind_paid_helper
local catvars1
local cvars2 tot_hrswk_help_i
local ivars2 ind_gt40 `home' creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst
local catvars2
local ivars3 
local catvars3 
local ivars4
gen n=1
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)
gen ind_gt40=tot_hrswk_help_i>40
foreach x of local ivars2 {
replace `x'=0 if missing(`x')
}
label var tot_hrswk_help_i "Total hours of help/week, mean"

forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 1 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'<3 {
			reg `x' incicat if inlist(incicat,`t',3)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+2
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB at N1" "P-value" "Concurrent HB" "P-value" "Non-HB") varlabels ///
sdec(2,3,2,3,2) annotate(stars) asymbol(*,**,NR) addtable note("P-values relative to non-homebound group")



H="table 1 and caregiving resources, 2 cats"
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

label var income_adj "Income, 2018$"
keep if sp_ivw==1 & !missing(prob_dem)
sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
by spid: egen firstnh=min(cond(nhres==1),wave,.)
drop if firstnh<=firstdem | missing(firstdem)
rename race_cat race
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2

label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"
gen incicat=hbcat_n1==1
replace incicat=2 if !incicat & hbcat==1
replace incicat=3 if !incicat & inlist(hbcat,2,3)
tab incicat
label define incicat 1 "Homebound at N1" 2 "Concurrently homebound" 3 "Not homebound"
label values incicat incicat
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"
drop if missing(hbcat) | missing(hbcat_n1)

local home 
foreach x of varlist home_di* {
	local home `home' `x'
}

replace incicat=2 if incicat==1

preserve
keep if incident
local cvars1 age 
local ivars1 female married educ_hs_ind
local catvars1 race
local cvars2 income_adj
local ivars2 
local catvars2 income_quart
local ivars3 shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair srh_fp rcfres
local catvars3 livearrang
local ivars4
gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'==3 {
			reg `x' incicat if inlist(incicat,`t',2)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+1
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles(""  "HB" "Non-HB" "P-value") varlabels ///
sdec(2,2,3) annotate(stars) asymbol(*,**,NR) replace note("P-values relative to non-homebound group")

restore

keep if incident
local cvars1 n_helpers
local ivars1 ind_no_helpers ind_paid_helper
local catvars1
local cvars2 tot_hrswk_help_i
local ivars2 ind_gt40 `home' creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst
local catvars2
local ivars3 
local catvars3 
local ivars4
gen n=1
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)
gen ind_gt40=tot_hrswk_help_i>40
foreach x of local ivars2 {
replace `x'=0 if missing(`x')
}
label var tot_hrswk_help_i "Total hours of help/week, mean"

forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',3,.)
mat stars=J(`rn',3,0)

foreach t in 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'==3 {
			reg `x' incicat if inlist(incicat,`t',2)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+1
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB" "Non-HB" "P-value") varlabels ///
sdec(2,2,3) annotate(stars) asymbol(*,**,NR) addtable note("P-values relative to non-homebound group")



H="*******************************"


H="Dataset Set Up ( No NSOC) "
*Variable Set Up, No NSOC Merge 

cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

import excel "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)
replace moved_tot = 0 if moved_tot !=. 

gen length_in_res = ht1yrslived if moved_total ==. 
replace length_in_res =. if ht1yrslived==-1
forvalues i = 2/8{
replace length_in_res = ht1yrslived+`i'-1 if wave ==`i' & moved_total ==. & length_in_res != -1 
}

*capture duplicates where there is 1 spid but several opid for same wave 
replace length_in_res = moved_tot if length_in_res ==. 
******
forvalues i = 2/8{
by spid: replace length_in_res = length_in_res[_n-1]+1 if length_in_res ==. & wave==wave[_n-1]+1 & wave==`i'
*by spid: replace length_in_res = length_in_res[_n-1] if length_in_res ==. & wave==wave[_n-1]& wave==`i'
}
******
replace length_in_res = . if ht1yrslived==.
tab length_in_res

gen length_in_res_3cat = 0 if length_in_res>=0 & length_in_res <=10
replace length_in_res_3cat=1 if length_in_res>=11 & length_in_res <=30
replace length_in_res_3cat=2 if length_in_res>=31 & length_in_res <.
tab length_in_res_3cat

label var length_in_res "Years at Residence"
label define length_in_res_3cat 0 "0 - 10 Years" 1 "11-30 Years" 2 "31+ Years "
label val length_in_res_3cat length_in_res_3cat
label var length_in_res_3cat "Years at Residence (3cat)"

*check 

forvalues i = 2/8 {
*tab length_in_res if re`i'spadrsnew==2
tab moved_total length_in_res if re`i'spadrsnew==2
duplicates report if re`i'spadrsnew==2
}



*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

*spids in which their incident dementia wave is dropped b/c they are missing hbcat & hbcat_n1
list spid wave incident firstdem  yearsample if spid==10003459 |spid == 10006546 |spid ==10007621  | spid ==10011112 

drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
drop if yearsample ==2015 
by spid: egen obs_incid=max(incident) //use after dropping those that missed hbcat
keep if obs_incid==1

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numconditions1-1 if sr_dementia_ever ==1
gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2" 1 "2-4" 2 "5+"
label values comorbid comorbid 
label var comorbid "# of Comorbidities"
label var sr_numcondit "# Med Conditions (excl Dementia)"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race (3 Cat)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_index "ADL Counts (Continuous)"

*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

*can break down as <10; 11-40; more than 40 depending on distribution
gen hrs_help_3cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=10
replace hrs_help_3cat = 1 if tot_hrswk_help_i >10 & tot_hrswk_help_i <=40 
replace hrs_help_3cat = 2 if tot_hrswk_help_i >40 & tot_hrswk_help_i<.
label define hrs_help_3cat 0 "0-10 Hrs" 1 ">10 -40 Hrs" 2 ">40 Hrs"
label values hrs_help_3cat hrs_help_3cat
label var  hrs_help_3cat "Total Hrs of Help(3cat)"
tab hrs_help_3cat

*total hrs of help 2cat
gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=20
replace hrs_help_2cat = 1 if tot_hrswk_help_i >20 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-20 Hrs" 1 ">20" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>20 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Financial Strain (Any nopay/mealskip)"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

*missing obsvn: 
* educ_hs_ind adl_index race3
*check education for these spids before limiting the sample 

save "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", replace 


H="Dataset Set Up (NSOC Merged)"
**variable set up only, merged with NSOCs
*incicat (t) 0: not hb, 1 hb in priorwave/concurrently
*clean this one up to just get current model 
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

import excel "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

merge 1:m spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\nsoc_round_1_7.dta", keep (master match) 

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\raw\NSOC_Round_5_SP_Tracker_File_V3.dta", keepusing(fl5dnsoc fl5dnsoccomp) keep (master match) nogen 

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\raw\NSOC_R7_Crss_SP_Tracker_File.dta", keepusing (fl7dnsoc fl7dnsoccomp)  keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)
replace moved_tot = 0 if moved_tot !=. 

gen length_in_res = ht1yrslived if moved_total ==. 
replace length_in_res =. if ht1yrslived==-1
forvalues i = 2/8{
replace length_in_res = ht1yrslived+`i'-1 if wave ==`i' & moved_total ==. & length_in_res != -1 
}

*capture duplicates where there is 1 spid but several opid for same wave 
replace length_in_res = moved_tot if length_in_res ==. 
forvalues i = 2/8{
by spid: replace length_in_res = length_in_res[_n-1]+1 if length_in_res ==. & wave==wave[_n-1]+1 & wave==`i'
by spid: replace length_in_res = length_in_res[_n-1] if length_in_res ==. & wave==wave[_n-1]& wave==`i'
}

replace length_in_res = . if ht1yrslived==.
tab length_in_res

*check 

forvalues i = 2/8 {
*tab length_in_res if re`i'spadrsnew==2
tab moved_total length_in_res if re`i'spadrsnew==2
duplicates report if re`i'spadrsnew==2
}

/*
merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_2\round_2\NHATS_Round_2_SP_File.dta", keepusing (fl2spdied re2spadrsnew   re2mthmove re2yearmove) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_3\round_3\NHATS_Round_3_SP_File.dta", keepusing (fl3spdied re3spadrsnew re3mthmove re3yearmove) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_4\round_4\NHATS_Round_4_SP_File.dta", keepusing (fl4spdied re4mthmove re4yearmove re4spadrsnew) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_5\round_5\NHATS_Round_5_SP_File.dta", keepusing (fl5spdied re5spadrsnew re5yearmove re5mthmove ht5yrslived) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_6\round_6\NHATS_Round_6_SP_File.dta", keepusing (fl6spdied re6spadrsnew re6mthmove re6yearmove) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_7\round_7\NHATS_Round_7_SP_File.dta", keepusing (fl7spdied re7spadrsnew re7mthmove re7yearmove) keep (master match) nogen

merge m:1 spid using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_8\round_8\NHATS_Round_8_SP_File.dta", keepusing (fl8spdied re8spadrsnew re8yearmove re8mthmove) keep (master match) nogen
*/
****************BRING BACK FROM UNTITLED#3 ***MERGE IN HOUSING VARS FROM ABOVE************************

*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

*spids in which their incident dementia wave is dropped b/c they are missing hbcat & hbcat_n1
list spid wave incident firstdem  yearsample if spid==10003459 |spid == 10006546 |spid ==10007621  | spid ==10011112 



drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
drop if yearsample ==2015 
by spid: egen obs_incid=max(incident) //use after dropping those that missed hbcat
****
tab wave _merge if firstdem ==2


keep if obs_incid==1

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numconditions1-1 if sr_dementia_ever ==1
gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2" 1 "2-4" 2 "5+"
label values comorbid comorbid 
label var comorbid "# of Comorbidities"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race (3 Cat)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_index "ADL Counts (Continuous)"

*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

*can break down as <10; 11-40; more than 40 depending on distribution
gen hrs_help_3cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=10
replace hrs_help_3cat = 1 if tot_hrswk_help_i >10 & tot_hrswk_help_i <=40 
replace hrs_help_3cat = 2 if tot_hrswk_help_i >40 & tot_hrswk_help_i<.
label define hrs_help_3cat 0 "0-10 Hrs" 1 ">10 -40 Hrs" 2 ">40 Hrs"
label values hrs_help_3cat hrs_help_3cat
label var  hrs_help_3cat "Total Hrs of Help(3cat)"
tab hrs_help_3cat

*total hrs of help 2cat
gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=20
replace hrs_help_2cat = 1 if tot_hrswk_help_i >20 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-20 Hrs" 1 ">20" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>20 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Financial Strain (Any nopay/mealskip)"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

******UPDATE: CAREGIVING variables************
*get unique num of cgs*
tostring spid, gen (spid_str)
egen spopid_str = concat(spid_str opid) if opid !=""
duplicates report spopid
bysort spopid: gen spopcount = _n if opid !=""
gen cg_count = spopcount==1

rename eligible_nsoc elig_r1_nsoc 
gen elig_r5_nsoc=fl5dnsoc==1
gen elig_r7_nsoc =fl7dnsoc ==1

gen comp_r1_nsoc = completed_nsoc
gen comp_r5_nsoc = fl5dnsoccomp>0 if fl5dnsoccomp!=.
gen comp_r7_nsoc = fl7dnsoccomp>0 if fl7dnsoccomp!=.

*see # of ppl with eligible & completed nsoc among incident dementia 
tab elig_r1 comp_r1 if incid ==1 & wave ==1 
tab elig_r5 comp_r5 if incid ==1 & wave ==5 
tab elig_r7 comp_r7 if incid ==1 & wave ==7 

gen informal_cg_help =n_helpers-n_paid_helpers
tab informal_cg_help
codebook spid if informal_cg_hel>0

gen cg_around=1 if firstdem==wave|wave ==firstdem-1|wave==firstdem+1

*******CG: Informal Care Eligible ****
*Informal Care: NSOC before incident dementia
sort spid wave
by spid: gen cg_pre_informal = informal_cg_help if firstdem ==wave+1 
codebook spid if cg_pre_informal > 0 & cg_pre_informal <. 

*Informal Care: Concurrent NSOC and incident dementia
by spid: gen cg_same_informal =informal_cg_help if firstdem==wave
codebook spid if cg_same_informal!=. & cg_same_informal >0

*Informal Care: NSOC after Incident Dementia 
by spid: gen cg_aft_informal = informal_cg_help if firstdem==wave-1 
codebook spid if cg_aft_informal!=. & cg_aft_informal >0

codebook spid if cg_around ==1 & informal_cg_help!=.& informal_cg_help >0
*/
*****CG: NSOC Eligible ****
sort spid wave
*NSOC Interview Before Incident Dementia
codebook spid if wave ==2 & elig_r1 ==1 & incident==1
codebook spid if wave ==6 & elig_r5 ==1 & incident ==1
codebook spid if wave == 8 & elig_r7 ==1 & incident ==1 

*NSOC Interview is Concurrent with Incident Dementia 
codebook spid if wave==5 & elig_r5==1 & incident ==1
codebook spid if wave==7 & elig_r7==1 & incident ==1
*gen eligsamewave5 = 1 if wave==5 & elig_r5==1 & incident ==1
*codebook spid if eligsamewave5==1
*gen eligsamewave7 = 1 if wave==7 & elig_r7==1 & incident ==1

*NSOC Interview is After Incident Dementia (incident dementia at wave 4 & nsoc is wave 5)
codebook spid if wave ==4 & elig_r5 ==1 & incident ==1 
codebook spid if wave ==6 & elig_r7 ==1 & incident ==1 


*NSOC Eligible: Prior/Concur/After Incident Dementia 
codebook spid if wave ==2 & elig_r1 ==1 & incident==1
codebook spid if wave ==6 & elig_r5 ==1 & incident ==1|wave==5 & elig_r5==1 & incident ==1|wave ==4 & elig_r5 ==1 & incident ==1 
codebook spid if wave == 8 & elig_r7 ==1 & incident ==1 |wave==7 & elig_r7==1 & incident ==1|wave ==6 & elig_r7 ==1 & incident ==1 

*****CG: NSOC Complete****
*NSOC Completed Prior to Incident Dementia 
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 8 & comp_r7 ==1 & incident ==1
**total unique spids in "nsoc prior to ID"
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 |wave ==6 & comp_r5 ==1 & incident ==1 | wave == 8 & comp_r7 ==1 & incident ==1

*NSOC Completed Concurrent to Incident Dementia 
codebook spid if wave ==5 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 7 & comp_r7 ==1 & incident ==1
**total unique spids in nsoc completed concur to incid dem 
codebook spid if wave ==5 & comp_r5 ==1 & incident ==1 | wave == 7 & comp_r7 ==1 & incident ==1

*NSOC Completed After to Incident Dementia 
codebook spid if wave ==4 & comp_r5 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r7 ==1 & incident ==1
**total unique spids in nsoc completed after incid dem 
codebook spid if wave ==4 & comp_r5 ==1 & incident ==1 | wave ==6 & comp_r7 ==1 & incident ==1

*NSOC Completed: Prior/Concur/After Incident Dementia 
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r5 ==1 & incident ==1 | wave ==5 & comp_r5 ==1 & incident ==1 | wave ==4 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 8 & comp_r7 ==1 & incident ==1| wave == 7 & comp_r7 ==1 & incident ==1|wave ==6 & comp_r7 ==1 & incident ==1


******CG:Num of NSOC Ivws*******
*Num of NSOC Completed Prior to Incident Dementia 
gen nsoc_pre = 1 if firstdem == wave+1
tab wave nsoc_pre if opid !=""
*Num of NSOC concurrent to Incident Dementia 
tab opid if firstdem ==wave 

*Num of NOSC after incident Dementia 
gen nsoc_aft =1 if firstdem ==wave-1
tab wave nsoc_aft if opid !=""

tab opid if nsoc_pre==1&opid !=""|firstdem ==wave|nsoc_aft==1 & opid!=""

*********************Below for NSOC Is MISC.******
*checks the pre, same, and afterdem 
tab firstdem wave if _merge ==3

**FIGURE OUT CG LIVING W/ SP VAR. PERCENTS INCLUDE ALL OBSVNS 
replace cg_lives_with_sp=cg_dist_cat==1 
*replace cg_lives_with_sp
tab cg_lives_with_sp
tab cg_dist_cat 

*missing obsvn: 
* educ_hs_ind adl_index race3
*check education for these spids before limiting the sample 

save "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_with_nsoc.dta", replace 


H="Table 1 for Incident Dementia SPs (No NSOC)"
*Table 1 
use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", clear
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

label var sr_numcondit "# Med Conditions (excl Dementia) - Mean"
label var length_in_res "Years at Residence - Mean"
label var adl_index "ADL Counts (Continuous)-Mean"
label var ind_paid_help "Paid Help Indicator"

local cvars1 age adl_index
local ivars1 female married educ_hs_ind hb shb indep_hb medicaid sr_phq2_depressed
local catvars1 race3
local ivars2 ind_paid_help  rcfres livealone metro_ind fin_strain
local catvars2 income_quart
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 sr_numcondit
local catvars4  comorbid 
local cvars5 tot_hrswk_help_i
local catvars5 hrs_help_3cat
local cvars6 length_in_res
local catvars6 length_in_res_3cat

gen n=1

forvalues i=1/6 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`cativars5'"

local rows
forvalues i=1/6 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 1 1 
local r=1
local c=1
*****insert incid dem full sample here 
mat tab=J(`rn',4,.)
mat stars=J(`rn',4,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy: mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if incicat ==0): mean ltpov
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate:svy, subpop(if incicat ==1): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate: svy: reg ltpov incicat
mat tab[`r',`c'+3]=e(p_mi)
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = 2

forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy : mean `x'
	mat tab[`r',`c']=e(b)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy : mean `x'
		mat tab[`r',`c']=e(b)*100
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if incicat==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy : mean `z'
		mat tab[`r',`c']=e(b)*100
			local r=`r'+1
			}
}
}

	*svy : mean n
	mat tab[`r',`c']=e(N_psu)
	local r = `r'+1 
	mat tab[`r',`c']=e(N_pop)

	local r=2

local c = `c'+1

foreach t in 0 1 {
forvalues i=1/6 {

	foreach x of local cvars`i' {
	svy, subpop(if incicat==`t'): mean `x'
		mat tab[`r',`c']=e(b)
		if `t'==1 {
			svy: reg `x' incicat
			*svy: reg `x' incicat if inlist(incicat,`t',0)
			test incicat 
			mat tab[`r',`c'+1]=e(p)
			mat stars[`r',`c'+1]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if incicat==`t'): mean `x'
		 mat tab[`r',`c']=e(b)*100

		if `t'==1 {
		svy: tab `x' incicat
		*svy: tab `x' incicat if inlist(incicat,`t',0)
		mat tab[`r',`c'+1]= e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if incicat==`t'): mean `x'
		if `t'==1 {
		svy: tab `x' incicat
		*svy: tab `x' incicat if inlist(incicat,`t',0)
		mat tab[`r',`c'+1]=e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incicat==`t'): mean `z'
			mat tab[`r',`c']=e(b)*100
			local r=`r'+1
			}
}
}
	svy, subpop(if incicat==`t'): mean n
	mat tab[`r',`c']==e(N_sub)
	local r = `r'+1 
	mat tab[`r',`c']==e(N_subpop)
	local r=2
	
	local c=`c'+1
}	

mat rownames tab= "Poverty Threshold"  `rows'  N "Estimated N"

mat list tab
frmttable using "inci_dem_tab1_2011only_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort w/ Survey Weights") ctitles("" "Incid Dem Full Sample" "InciDem & non-HB" "InciDem & HB(Prior-Concur)" "P-value") varlabels sdec(2,2,2,3) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group") replace

restore

*Table for wave at incident dementia 
preserve
keep if incident ==1
svyset spid [pw=anfinwgt], strata(varstrat)
mat tab = J(8,4,.)
local r = 1

forvalues i =2/8 {
tab wave`i'_incid if wave`i'_incid ==1
mat tab [`r',1]= r(N)
sum wave`i'_incid
mat tab [`r',2] =r(mean)*100
svy : mean wave`i'_incid if wave`i'_incid==1
mat tab [`r', 3]= e(N_pop)
svy: mean wave`i'_incid
mat tab[`r',4]==e(b)*100
local r = `r'+1
}
gen n = 1
svy: mean n
mat tab[`r',1]= e(N)
mat tab [`r', 3]= e(N_pop)

mat list tab 

mat rownames tab = "Wave 2" "Wave 3" "Wave 4" "Wave 5" "Wave 6" "Wave 7" "Wave 8" "Total"
frmttable using "inci_dem_tab1_2011only_`c(current_date)'.rtf", statmat(tab) title("Wave at Incident Dementia") ctitles("" "# of Incident Dementia" "Unweighted %" "Weighted # of Incident Dementia" "Weighted %") varlabels sdec(2,2,2,2) addtable

restore


H="Logit Models (by SPID, No NSOC Merge)"
*Logit Tables w/o Merging NSOC 

cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"
use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", clear

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

****Current Logit Model**********
preserve
outreg, clear 
keep if incident ==1
local allvars age i.race3 female educ_hs_ind adl_index rcfres i.comorbid metro_ind ind_paid_help ltpov
local stratvars age female educ_hs_ind adl_index rcfres i.comorbid metro_ind ind_paid_help ltpov

mi estimate, or:svy, subpop(if incident==1): logit incicat `allvars' 
mi estimate, post 
*mi estimate, or post


*outreg using "Logit_2011_weight_mi_`c(current_date)'_no_nsoc.rtf", replace stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle ("" "Full Sample") note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")

*outreg using "Stratified_Logit_2011_weight_mi_`c(current_date)'_no_nsoc.rtf", replace stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle ("" "Full Sample") note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")

mi estimate, or:svy, subpop(if incident==1 & race3==0): logit incicat `stratvars' 
mi estimate, post 
*outreg using "Stratified_Logit_2011_weight_mi_`c(current_date)'_no_nsoc.rtf", merge stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle("" "White")note("OR is displayed. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")

mi estimate, or:svy, subpop(if incident==1 & race3==1): logit incicat `stratvars' 
mi estimate, post 
*outreg using "Stratified_Logit_2011_weight_mi_`c(current_date)'_no_nsoc.rtf", merge stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle("" "Black")note("OR is displayed. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")

mi estimate, or:svy, subpop (if incident==1 & race3==2): logit incicat `stratvars'
mi estimate, post 
*outreg using "Stratified_Logit_2011_weight_mi_`c(current_date)'_no_nsoc.rtf", merge stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle("" "Hispanic")note("OR is displayed. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")

/*
mi estimate, or: logit incicat `modelvars' if incid
mi estimate, post 
outreg using "Logit_2011_weight_mi_`c(current_date)'.rtf", merge stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") ctitle("" "No Weights")note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers")
*/

restore
*Among those with incident dementia, people who are Hispanic have 2.146 times the odds of being homebound compared to those who are not Hispanic 
*Among those who are incident dementia and Black, people with 5+ comorbidities have 9.550 times the odds of being homebound compared to those with less than 2 comorbidities  

H="Changelog"
********************Change Log******************** 
Updates:
7/7/20
-----------
sent new table & logit models to KO & JR, Add: among those who are non-hb, how many become hb in next wave, How many moved within the last 5 years of incident dementia, and how many moved to assisted living? (categorical, relative to not moving in past 5 yrs); check stratify by race, not multivariate! 


6/29/20 
-----------
Analysis 1, Table 1: changes from KO email on 6/29/20 (add new vars to Table 1- envrtl measures, social cohesion, types of house, etc), add caregiving strain variables 
Analysis 1, Logit Model: remove living alone from logit model, Stratify analyses by race:  Hispanic, white, black - for description section,
Analysis 2: KO & Jenny to discuss abt Caregiving before/after incident dementia diagnosis (pd care, care hours, etc) 
touch base w/ Evan & Naomi to check her incident cancer & NHATS on 7/9/20

6/22/20
------------
create flowchart of SPIDS & CGs before/concur/after incident dementia wave

6/15/20
-------------
use corrected NHATS income var dataset(from MH) & add incidementia full 2011 cohort to table 1. At time of dementia, caregiving, hbstatus, comorbidities, adls. Use weighted variables. Explore family systems & support (might be different by race) Take a look at NSOC (cg ivws-pd/unpd) @ incid dementia wave (cg: yrs 1,5,7) 

6/1/20 CY
-------------
from NHATS technical paper, use indivs who entered at 2011 only. add survey weights for 2011, correct poverty threshold % and add income quartiles, Hrs of assistance to Table 1 (6/10/20) 

5/26/20 CY
---------
use new metro indicator & update with poverty indicator & new income variable(correct missingness), check multicollinearity, carry forward poverty thresh for indiv in missing incid dementia sample. For % of poverty level: take % poverty level and make discrete. Divid everything by poverty level & everything less than/equal to 1 is below poverty level. (ie. if poverty level is 10,000 and person makes 60,000, person is 600% poverty level). Poverty & income is correlated, so just use poverty var. mi import for multip imputations for poverty. 

5/18/20 CY
------------
KO Mtg: use 3 Category of ADL Counts, with no ADL as reference group in logit models instead of Help 1+ ADL. Consider adding severe dementia into model but unsure how it would be interpreted.. 
email from KO 5/21 & 5/22 - use continuous ADL instead of categorical, lives alone, comorbidities 
Vars with Missing Observations: 19 missing race, 18 missing Education, 7 missing ADL counts 

5/11/20 CY
------------
@KO Mtg: ADL had highest OR (>4+), decide to look at ADL and severe dementia. Does functional impairment lead to HB? use Jenny's severe dementia categories or existing ADL categories. 
Dementia Cats: No dem, poss dem, or prob dem
How many have severe dementia @ incid dementia? Not severe Dementia & not hb? Severe Dem & hb?
ADLn1 correlated w/ ADL impairments  

5/7/20 CY
------------
Logit Models & best model fits for demographics 
when all demog vars are incl in the model, being in bottom income group is best model (lowest aic)
*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model. 
Living arrangement vs Married>(both had same results in model)>livearrang selected b/c most unmarried were in "LiveAlone or Live w/ Others", most married "Lived w/ Partners or lived with partners +Others"
Combined White w/ Other Race b/c other race had small numbers 
*Chosen Demographic Model: logit incicat age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 adl_imp_n1 adl_impair & (n_helpers/ind_paid_helper/ind_help40hrs)

4/24/20 EBL
-------------
Table: demographic and caregiving characteristics of concurrently hb & indep (2 categories) and hb@n1, concurr hb & not hb (3 cats) 

4/10/20 CY
------------ 
Incident dementia & homebound status before/concurrent/after incident dementia wave 

4/3/20 CY
------------
Sample derivations of incident dementia

Old Vars No Longer Needed
-----------------------
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"


*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"


*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

*gen sev_dem=0
*replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

* don't need poverty indicators below b/c have ltpov var
*gen poverty indicator for ppl income is less than poverty threshold 
/*
gen poverty_ind= poverty_thresh >= aveincome & poverty_thresh!=.
replace poverty_ind =. if poverty_thres==.
tab poverty_ind
label var poverty_ind "Poverty Indicator"

*poverty percent 
gen pov_perc = aveincome/poverty_thres if poverty_thresh !=. //if hhm==1
gen ind_pov_perc = pov_perc<=1
*/